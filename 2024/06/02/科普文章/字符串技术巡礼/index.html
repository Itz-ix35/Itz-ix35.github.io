<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"itz-ix35.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"show_result":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="讲解了若干与字符串有关的算法">
<meta property="og:type" content="article">
<meta property="og:title" content="科普文章 - 字符串技术巡礼">
<meta property="og:url" content="https://itz-ix35.github.io/2024/06/02/%E7%A7%91%E6%99%AE%E6%96%87%E7%AB%A0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%80%E6%9C%AF%E5%B7%A1%E7%A4%BC/index.html">
<meta property="og:site_name" content="ix35&#39;s Blog">
<meta property="og:description" content="讲解了若干与字符串有关的算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/dijjldb4.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/wdz70e7c.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/8t9xzsya.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/aabashdj.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/uxtzry61.png">
<meta property="article:published_time" content="2024-06-02T05:02:49.818Z">
<meta property="article:modified_time" content="2025-02-22T11:47:10.131Z">
<meta property="article:author" content="ix35">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.luogu.com.cn/upload/image_hosting/dijjldb4.png">


<link rel="canonical" href="https://itz-ix35.github.io/2024/06/02/%E7%A7%91%E6%99%AE%E6%96%87%E7%AB%A0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%80%E6%9C%AF%E5%B7%A1%E7%A4%BC/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://itz-ix35.github.io/2024/06/02/%E7%A7%91%E6%99%AE%E6%96%87%E7%AB%A0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%80%E6%9C%AF%E5%B7%A1%E7%A4%BC/","path":"2024/06/02/科普文章/字符串技术巡礼/","title":"科普文章 - 字符串技术巡礼"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>科普文章 - 字符串技术巡礼 | ix35's Blog</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ix35's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-essays"><a href="/essay/" rel="section"><i class="fa fa-tags fa-fw"></i>随笔选辑</a></li><li class="menu-item menu-item-game-guide"><a href="/game-guide/" rel="section"><i class="fa fa-tags fa-fw"></i>游戏攻略</a></li><li class="menu-item menu-item-game-review"><a href="/game-review/" rel="section"><i class="fa fa-tags fa-fw"></i>游戏评测</a></li><li class="menu-item menu-item-music"><a href="/music/" rel="section"><i class="fa fa-tags fa-fw"></i>音乐分享</a></li><li class="menu-item menu-item-notes"><a href="/note/" rel="section"><i class="fa fa-tags fa-fw"></i>课程笔记</a></li><li class="menu-item menu-item-solutions"><a href="/solution/" rel="section"><i class="fa fa-tags fa-fw"></i>专题题解</a></li><li class="menu-item menu-item-technology"><a href="/technology/" rel="section"><i class="fa fa-tags fa-fw"></i>科普文章</a></li><li class="menu-item menu-item-travelogue"><a href="/travel/" rel="section"><i class="fa fa-tags fa-fw"></i>远古游记</a></li><li class="menu-item menu-item-gallery"><a href="/gallery/" rel="section"><i class="fa fa-image fa-fw"></i>画廊</a></li><li class="menu-item menu-item-data"><a href="/data/" rel="section"><i class="fa fa-database fa-fw"></i>数据</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%80%E6%9C%AF%E5%B7%A1%E7%A4%BC"><span class="nav-text">字符串技术巡礼</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%AE%B0%E5%8F%B7%E4%B8%8E%E7%BA%A6%E5%AE%9A"><span class="nav-text">1. 记号与约定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-text">2. 前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91"><span class="nav-text">字典树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-text">自动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Border-%E5%92%8C%E5%91%A8%E6%9C%9F"><span class="nav-text">Border 和周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aho-Corasick-%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-text">Aho-Corasick 自动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84"><span class="nav-text">后缀数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%BC%80%E6%A0%91"><span class="nav-text">后缀树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-text">后缀自动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E6%A0%91-%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-text">回文树 &#x2F; 回文自动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Manacher-%E7%AE%97%E6%B3%95"><span class="nav-text">Manacher 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Z-%E5%87%BD%E6%95%B0"><span class="nav-text">Z 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%8C%BA%E9%97%B4-Border-%E5%9F%BA%E6%9C%AC%E5%AD%90%E4%B8%B2%E5%AD%97%E5%85%B8"><span class="nav-text">3. 区间 Border &#x2F; 基本子串字典</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AF%B9%E7%A7%B0%E5%8E%8B%E7%BC%A9-SAM-%E5%9F%BA%E6%9C%AC%E5%AD%90%E4%B8%B2%E7%BB%93%E6%9E%84"><span class="nav-text">4. 对称压缩 SAM &#x2F; 基本子串结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Lyndon-%E5%88%86%E8%A7%A3-Significant-Suffix"><span class="nav-text">5. Lyndon 分解 &#x2F; Significant Suffix</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%B9%82%E4%B8%B2-Runs"><span class="nav-text">6. 幂串 &#x2F; Runs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%9D%82%E6%8A%80"><span class="nav-text">7. 杂技</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ix35"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">ix35</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Itz-ix35" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Itz-ix35" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2757336405@qq.com" title="E-Mail → mailto:2757336405@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.luogu.com.cn/user/113546" title="Luogu → https:&#x2F;&#x2F;www.luogu.com.cn&#x2F;user&#x2F;113546" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>Luogu</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/187505795" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;187505795" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i>Bilibili</a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://itz-ix35.github.io/2024/06/02/%E7%A7%91%E6%99%AE%E6%96%87%E7%AB%A0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%80%E6%9C%AF%E5%B7%A1%E7%A4%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="ix35">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ix35's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="科普文章 - 字符串技术巡礼 | ix35's Blog">
      <meta itemprop="description" content="讲解了若干与字符串有关的算法">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          科普文章 - 字符串技术巡礼
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-02 13:02:49" itemprop="dateCreated datePublished" datetime="2024-06-02T13:02:49+08:00">2024-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A7%91%E6%99%AE%E6%96%87%E7%AB%A0/" itemprop="url" rel="index"><span itemprop="name">科普文章</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">讲解了若干与字符串有关的算法</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="字符串技术巡礼"><a href="#字符串技术巡礼" class="headerlink" title="字符串技术巡礼"></a>字符串技术巡礼</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要内容是一些许多人不怎么会的字符串组合算法，而主要内容基本可以理解为论文导读。笔者认为，许多技术是可以被放入（甚至可以说很适合被放入）OI 的框架中的，只是由于这些技术引入 OI 的时机较晚，因此尚未得到普及。</p>
<hr>
<h2 id="1-记号与约定"><a href="#1-记号与约定" class="headerlink" title="1. 记号与约定"></a>1. 记号与约定</h2><p>字符集是一个全序集，默认是有限的，记为 $\Sigma$。</p>
<p>字符串是由若干字符（字符集的元素）构成的序列，字符串的集合记为 $\Sigma^*$，一般用小写字母 $u,v,w$ 等表示字符串，也有时用大写字母 $S,T$ 表示字符串。</p>
<ul>
<li><p>字符串 $w$ 的长度定义为包含的字符数量，记为 $|w|$。</p>
</li>
<li><p>若 $|w|=0$，则定义 $w$ 为空串，记为 $\varepsilon$，空串是唯一的。</p>
</li>
<li><p>记 $\Sigma^+=\Sigma^* - \{\varepsilon\}$。</p>
</li>
<li><p>记 $w_i$ 表示 $w$ 的第 $i$ 个字符。</p>
</li>
<li><p>记 $w[l,r]$ 或 $w[l\ldots r]$ 表示由 $w_l,\ldots,w_r$ 组成的字符串，称为 $w$ 的一个子串。当 $l&gt;r$ 时定义 $w[l,r]=\varepsilon$。</p>
</li>
<li><p>称 $w[1,i]$ 为 $w$ 的一个前缀，$w[i,n]$ 为 $w$ 的一个后缀。</p>
</li>
<li><p>若 $w$ 的一个子串（前缀/后缀）不等于 $w$，则称其为真子串（真前缀/真后缀）。</p>
</li>
<li><p>若 $u$ 是 $v$ 的前缀，记作 $u\sqsubseteq v$；若 $u$ 是 $v$ 的真前缀，记作 $u\sqsubset v$。</p>
</li>
<li><p>对于两个串 $u,v$，$u+v$ 或 $uv$ 定义为一个长度为 $|u|+|v|$ 的串 $w$，其中 $w_i=u_i (i\leq |u|), w_i=v_{i-|u|} (i&gt;|u|)$，称为 $u,v$ 的拼接。</p>
</li>
<li><p>定义 $\operatorname{Rev}(u)$ 为一个长度为 $|u|$ 的串 $v$，其中 $v_i=u_{|u|-i+1}$。</p>
</li>
<li><p>若 $w=\operatorname{Rev}(w)$，则称 $w$ 为回文串。</p>
</li>
<li><p>定义 $\operatorname{LCP}(u,v)$ 表示最大的 $i$ 使得 $i\leq \min(|u|,|v|)$ 且 $u[1,i]=v[1,i]$。</p>
</li>
<li><p>定义 $\operatorname{LCS}(u,v)$ 表示最大的 $i$ 使得 $i\leq \min(|u|,|v|)$ 且 $u[|u|-i+1,|u|]=v[|v|-i+1,|v|]$。</p>
</li>
<li><p>对于两个串 $u,v$，我们称 $u$ 的字典序比 $v$ 小，或 $u&lt;v$，当且仅当以下条件满足至少一个：</p>
<ul>
<li><p>$u\sqsubset v$；</p>
</li>
<li><p>存在一个 $1\leq i\leq \min(|u|,|v|)$ 使得 $u[1,i-1]=v[1,i-1], u_i&lt;v_i$，将这种情况记为 $u\lhd v$。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2. 前置知识"></a>2. 前置知识</h2><p>并非在每种技术中都会用到全部的前置知识，但这些是字符串理论的基础，几乎都在 NOI 大纲内。</p>
<h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><p>不再赘述。</p>
<h3 id="自动机"><a href="#自动机" class="headerlink" title="自动机"></a>自动机</h3><p>不再赘述。</p>
<p>我们通常考虑有限状态自动机，其中分为确定性有限状态自动机和非确定性有限状态自动机。字典树也可以看作一个自动机。</p>
<h3 id="Border-和周期"><a href="#Border-和周期" class="headerlink" title="Border 和周期"></a>Border 和周期</h3><p>对于字符串 $w$，若整数 $0&lt;p\leq |w|$ 满足 $w_i=w_{i+p} (i\leq |w|-p)$，则称 $p$（或 $w[1,p]$）是 $w$ 的一个周期。</p>
<p>若整数 $0\leq p&lt;|w|$ 满足 $w[1,p]=w[|w|-p+1,|w|]$，则称 $p$（或 $w[1,p]$）是 $w$ 的一个 Border。</p>
<p><strong>结论：$p$ 是 $w$ 的周期当且仅当 $|w|-p$ 是 $w$ 的 Border。</strong></p>
<p><strong>定理（周期引理，Periodicity Lemma）：若 $p,q$ 都是 $w$ 的周期，且 $p+q\leq |w|+\gcd(p,q)$，则 $\gcd(p,q)$ 是 $w$ 的周期。</strong></p>
<p>弱周期引理（Weak Periodicity Lemma，WPL）是一个弱化版本，即将上述条件替换为 $p+q\leq |w|$。</p>
<p><strong>结论：$w$ 的长度在 $(x,2x]$ 中的所有 Border 构成一个等差数列。对于周期，有类似的结论。</strong></p>
<p>我们可以 $O(|w|)$ 地求出 $w$ 的全部周期或 Border。</p>
<h3 id="Aho-Corasick-自动机"><a href="#Aho-Corasick-自动机" class="headerlink" title="Aho-Corasick 自动机"></a>Aho-Corasick 自动机</h3><p>对于一个字符串集合 $W=\{w_1,\ldots,w_k\}$，令 $W_p$ 是每个 $w_i$ 的所有前缀构成的集合。建立 $W_p$ 的字典树 $T$，字符串 $u$ 对应的树上结点记为 $f(u)$。</p>
<p>对于树上结点 $x$，设 $u=f^{-1}(x)$，$v$ 是 $u$ 的最长的属于 $W_p$ 的真后缀，定义 $B_x=f(v)$。数组 $B$ 称为失配数组。以 $B_x$ 为 $x$ 的父结点将形成一棵树 $T’$，称为失配树。</p>
<p>令：</p>
<script type="math/tex; mode=display">tr(x,c)=\begin{cases}ch(x,c)  & (\exists ch(x,c)) \\ tr(B_x,c) & (\text{otherwise})\end{cases}</script><p>其中 $ch(x,c)$ 表示 $T$ 上与 $x$ 之间边的字符为 $c$ 的子结点。</p>
<p>以 $tr$ 为转移，这得到了一个自动机，称为 $W$ 的 Aho-Corasick 自动机，简称 AC 自动机（ACAM）。</p>
<p>当 $W=\{w\}$ 时，这种特化的单串 AC 自动机称为 KMP 自动机，失配数组的含义为 $w$ 的每个前缀的最长 Border 位置。</p>
<p><strong>结论：设串 $u$ 在 $W$ 的 AC 自动机上运行到点 $x$，则 $u$ 的最长的属于 $W_p$ 的后缀为 $f^{-1}(x)$。</strong></p>
<p><strong>结论：$W_p$ 中所有 $f^{-1}(x)$ 的后缀恰好是所有 $f^{-1}(y)$，$y$ 取遍 $x$ 在失配树上的祖先。</strong></p>
<p>我们可以 $O(\sum_{w\in W}|w|\log |\Sigma|)$ 地建立 $W$ 的 ACAM（事实上，是 $O(\sum_{w\in W}|w|+|T|\log |\Sigma|)$，其中 $|T|$ 是字典树结点数）。</p>
<h3 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h3><p>定义排列 $\operatorname{SA}_w(1),\ldots,\operatorname{SA}_w(|w|)$ 表示：$w$ 的第 $i$ 小的非空后缀为 $w[\operatorname{SA}_w(i),|w|]$。</p>
<p>定义排列 $\operatorname{ISA}_w(1),\ldots,\operatorname{ISA}_w(|w|)$ 为 $\operatorname{SA}_w(1),\ldots,\operatorname{SA}_w(|w|)$ 的逆排列。有时 $\operatorname{ISA}$ 也写作 $\operatorname{Rank}$。</p>
<p>对于 $2\leq i\leq |w|$，定义 $\operatorname{Height}_w(i)=\operatorname{LCP}(w[\operatorname{SA}_w(i-1),|w|],w[\operatorname{SA}_w(i),|w|])$。</p>
<p><strong>结论：$\operatorname{LCP}(w[\operatorname{SA}_w(x),|w|],w[\operatorname{SA}_w(y),|w|])=\min_{i=x+1}^y \{\operatorname{Height}_w(i)\}$，其中 $x&lt;y$。</strong></p>
<p>我们可以 $O(|w|)$ 地建立 $w$ 的 SA，但是常用算法是 $O(|w|\log |w|)$ 的。</p>
<h3 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h3><p>设 $w$ 的所有后缀组成的集合为 $W_s$，$W_s$ 的字典树称为 $w$ 的后缀字典树。</p>
<p>将字典树上所有度数为 $2$ 的非根结点缩去（缩到边上），得到的树称为 $w$ 的隐式后缀树。</p>
<p>如果只缩那些不对应 $w$ 的后缀的结点，那么得到的树称为 $w$ 的后缀树（注意，这只是本文的约定）。</p>
<p>也有一种说法是在 $w$ 的末尾加上一个不同于 $w$ 中任何字符的字符 $\$$，得到 $\hat w$，其（按上述定义的）后缀树称为 $w$ 的（显式）后缀树。</p>
<p>类似我们在 AC 自动机中所做的，可以求出失配数组 $B_x$，在这里称为后缀链接，记为 $\operatorname{lk}(x)$。</p>
<p><strong>结论：后缀树结点数为 $O(|w|)$。</strong></p>
<h3 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h3><p>能接收 $w$ 所有子串的最小 DFA，称为 $w$ 的后缀自动机（SAM）。</p>
<p>记 $\operatorname{Endpos}(u)$ 和 $\operatorname{Startpos}(u)$ 分别表示 $u$ 在 $w$ 中作为子串出现的左端点集合和右端点集合。</p>
<p><strong>结论：后缀自动机状态数和转移数为 $O(|w|)$。</strong></p>
<p><strong>结论：后缀自动机的每个结点代表一族 $\operatorname{Endpos}$ 相等的子串，它们是其中最长者的最长的一部分后缀。</strong></p>
<p><strong>结论：$\operatorname{Endpos}$ 集合只有不交和包含两种关系，以此可以建出一棵树，称为 SAM 的树结构，这棵树等价于反串 $\operatorname{Rev}(w)$ 的后缀树。</strong></p>
<p>我们可以 $O(|w|\log |\Sigma|)$ 地建立 $w$ 的后缀树和 SAM。</p>
<h3 id="回文树-回文自动机"><a href="#回文树-回文自动机" class="headerlink" title="回文树 / 回文自动机"></a>回文树 / 回文自动机</h3><p>将 $w$ 的每个回文子串对应到一个结点，另外建立两个特殊结点分别称为奇根和偶根。令字符串 $u$ 对应的结点为 $f(u)$，则：$|u|=1$ 时 $f(u)$ 的父结点为奇根；$|u|=2$ 时 $f(u)$ 的父结点为偶根；否则 $f(u)$ 的父结点为 $f(u[2,|u|-1])$。这将得到一个有两个根的森林结构，称为回文树。</p>
<p>对于一个回文串 $u$，将其长度为 $\lceil\frac{|u|}{2}\rceil$ 的后缀称为其半串。回文树可以看作是所有回文子串对应的半串的 Trie（但对长度为奇数和偶数的回文串有特殊的标识分开），于是我们可以构造它的 ACAM，这样构造出的自动机结构称为回文自动机（PAM），类似可以定义失配指针 $B_x$ 和失配树。</p>
<p><strong>结论：回文串的所有 Border 都是回文串，回文子串 $u$ 的最长 Border 等于其最长回文真后缀，为 $f(u)$ 在回文自动机上失配指针指向的结点对应的回文子串。</strong></p>
<p>我们可以 $O(|w|\log |\Sigma|)$ 地建立 $w$ 的 PAM。</p>
<h3 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h3><p>我们可以 $O(|w|)$ 地对于每个 $i\in [1,|w|]$ 求出最大的 $j$ 使得 $w[i-j+1,i+j-1]$ 是回文串。</p>
<h3 id="Z-函数"><a href="#Z-函数" class="headerlink" title="Z 函数"></a>Z 函数</h3><p>我们可以 $O(|w|)$ 地对于每个 $i\in [1,|w|]$ 求出 $\operatorname{LCP}(w,w[i,|w|])$。</p>
<hr>
<h2 id="3-区间-Border-基本子串字典"><a href="#3-区间-Border-基本子串字典" class="headerlink" title="3. 区间 Border / 基本子串字典"></a>3. 区间 Border / 基本子串字典</h2><blockquote>
<p>论文：陈孙立，子串周期查询问题的相关算法及其应用，IOI 2019 集训队论文集</p>
</blockquote>
<p>基本子串字典被引入 OI 可能主要是为了解决区间 Border 问题，即：</p>
<ul>
<li>给定一个字符串 $w$，有 $q$ 次询问，每次给定一个 $w$ 的子串 $w[l,r]$，求它的 Border 集合。</li>
</ul>
<p>根据 Border 的相关知识，我们知道 $w[l,r]$ 的 Border 可以表示成 $O(\log(r-l+1))$ 个等差数列的（不相交）并，我们希望得到一种 $O(\log(r-l+1))$ 的算法求出这些等差数列（作为 Border 集合的一种表示）。</p>
<ul>
<li><strong>定义：考虑 $w$ 的所有长度为 $2^k$ 的子串 $w[i,i+2^k-1]$，给予它们标号 $N_k(i)$ 使得 $N_k(i)\leq N_k(j) \iff w[i,i+2^k-1]\leq w[j,j+2^k-1]$，且 $N_k(i)$（关于 $i$）的值域是连续的正整数。对于所有 $k$，这一系列标号数组 $N_k$ 称为 $w$ 的基本子串字典。</strong></li>
</ul>
<p>对于任意字符串 $w$，我们之前已经给出了一个结论：$w$ 的长度在 $(x,2x]$ 间的 Border 构成等差数列。于是现在我们的想法就是把子串 $w[l,r]$ 的 Border 长度划分为 $(1,2],(2,4],(4,8]$ 这些由 $2$ 的幂为端点的区间，每一段区间内 Border 都占据一个等差数列。现在我们考虑如何求长度处在 $(2^k,2^{k+1}]$ 中的所有 Border。</p>
<ul>
<li><p><strong>引理 1：对于字符串 $u,w$，如果 $2\times |u|\ge |w|$，则 $u$ 在 $w$ 中作为子串出现时的左端点构成了一个等差数列。</strong></p>
</li>
<li><p>证明：如果 $u$ 在 $w$ 中的出现次数不超过 $2$，则结论显然。下面考虑 $u$ 出现至少三次的情形。<br>考虑任意三次相邻的 $u$ 的出现，设其左端点分别是 $l,l+p_1,l+p_1+p_2$，由 $2|u|\ge |w|$ 可知 $p_1+p_2\leq |u|$，那么因为 $p_1,p_2$ 都是 $u$ 的周期，所以根据 WPL 可知 $p_0=\gcd(p_1,p_2)$ 也是 $u$ 的周期。</p>
<p>考虑这三次出现的并，即 $w[l,l+p_1+p_2+|u|-1]$，由 $p_0$ 是 $u$ 的周期不难得到 $p_0$ 是 $w[l,l+p_1+p_2+|u|-1]$ 的周期，从而 $l+p_0$ 或 $l+p_1+p_0$ 也是合法的（即 $u$ 出现的）左端点，而这与 $p_1\ne p_2$ 的假设矛盾（其中至少一个不等于 $p_0$），因此原命题得证。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/dijjldb4.png" alt=""></p>
</li>
</ul>
<p>设 $p$ 是 $u$ 的最小周期。注意到 $p_1+p_2\leq |u|\longrightarrow \min(p_1,p_2)\leq \frac{|u|}{2}$，所以其中必有一个 $p$ 的倍数，那么按照和上面类似的推理过程可以得到下述推论：</p>
<ul>
<li><strong>推论：在上述引理的条件下，如果 $u$ 在 $w$ 中出现至少三次，则这些出现的左端点构成的等差数列公差等于 $u$ 的最小周期。</strong></li>
</ul>
<p>让我们回到需要求解的问题：求出 $w[l,r]$ 的长度在 $(2^k,2^{k+1}]$ 中的所有 Border。</p>
<p>考虑 $u=w[l,l+2^{k+1}-1], u_0=[l,l+2^k-1], v=w[r-2^{k+1}+1,r], v_0=w[r-2^k+1,r]$，设 $u_0$ 在 $v$ 中的出现位置集合为 $S_1$，$v_0$ 在 $u$ 中出现位置集合为 $S_2$。那么每有一个 $(2^k,2^{k+1}]$ 中的 Border $x$，就必有对应的一个 $S_1$ 及 $S_2$ 中的元素（即由 $x$ 是 Border 蕴含的 $u_0$ 在 $v$ 中的出现以及 $v_0$ 在 $u$ 中的出现），因此将 $S_1,S_2$ 平移后求交就是 Border 集合了。</p>
<p>根据引理 1，$S_1,S_2$ 都是等差数列，但下面我们要得出一个更强的结论：</p>
<ul>
<li><p><strong>引理 2：如果 $|S_1|&gt;2$ 且 $|S_2|&gt;2$，则它们的公差相等。</strong></p>
</li>
<li><p>证明：根据上一个引理及其推论，可知此时 $S_1$ 的公差等于 $u_0$ 的最小周期 $p_u$，$S_2$ 的公差等于 $v_0$ 的最小周期 $p_v$，假设 $p_u\ne p_v$。</p>
<p>以 $p_u&gt;p_v$ 为例，$p_u<p_v$ 的情况是类似的。考虑 $u_0$ 在 $v$ 中最靠右的一次出现，设其与 $v_0$ 部分的交为 $y$。一方面 $y$ 是 $v_0$ 的前缀，从而有周期 $p_v$，另一方面根据 $u_0$ 在 $v$ 中的出现可知 $p_u$ 也是 $y$ 的周期，且 $|y|\ge 2\times p_u>p_u+p_v$，从而 $p=\gcd(p_u,p_v)$ 也是 $y$ 的周期。</p>
<p>这说明 $p$ 也是 $u_0[|u_0|-p_u+1,|u_0|]$ 的周期，从而是 $u_0$ 的周期，这与 $p_u$ 的最小性矛盾。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/wdz70e7c.png" alt=""></p>
</li>
</ul>
<p>于是如果我们已知 $S_1,S_2$，就可以 $O(1)$ 求出这两个等差数列的交（如果其中有一个大小不超过 $2$ 则平凡，否则公差相同容易合并）。下面考虑如何 $O(1)$ 求出 $S_1,S_2$。</p>
<p>这就要用到基本子串字典。以 $S_1$ 为例，我们实际上要找到以 $[r-2^{k+1}+1,r-2^k]$ 开头的长度为 $2^k$ 的子串中有哪些等于 $u_0$。而对于一个等差数列，只需要找到首项、末项和第二项就可以得到整个数列，所以我们只需找到使得 $i\in [r-2^{k+1}+1,r-2^k]$ 且 $N_k(i)=N_k(l)$ 的 $i$ 的最小、次小、最大值即可。</p>
<p>将序列以 $2^k$ 为块长分块，则每一块中使得 $N_k(i)=N_k(l)$ 的 $i$ 都应该是个等差数列（因为总可以表示成“某个子串的长度在 $(2^k,2^{k+1}]$ 中的 Border 集合”的形式），设第 $x$ 块中这个等差数列是 $s(l,x)$，查询时我们只需求出至多两块（因为查询区间长度是 $2^k$）然后将它们的结果拼接即可。那么某一个 $s(l,x)$ 如何查询呢？这可以使用哈希表完成：因为 $s(l,x)\ne \varnothing$ 的 $(l,x)$ 只有 $O(n)$ 种（因为总共只有 $n-2^k+1$ 个长度为 $2^k$ 的子串）。</p>
<p>于是，我们 $O(\log(r-l+1))$ 地支持了查询区间 Border 集合，将哈希表换为二分可以得到一个也许稍微简洁的 $O(\log(r-l+1)\log n)$ 算法。</p>
<p>基本子串字典还有一些其他应用，例如：</p>
<ul>
<li><p>问题：给定字符串 $w$，$q$ 次询问其中两个子串是否相等。</p>
<p>若两个子串分别是 $w[a,a+l-1]$ 和 $w[b,b+l-1]$，找到最大的 $k$ 使得 $2^k\leq l$，则两个子串相等等价于 $N_k(a)=N_k(b)$ 且 $N_k(a+l-2^k)=N_k(b+l-2^k)$。<br>预处理 $O(|w|\log |w|)$，查询 $O(1)$。</p>
</li>
<li><p>树上扩展</p>
<p>基本字串字典的概念可以直接扩展到树上，只不过将“以 $x$ 为左端点长度为 $2^k$ 的子串”换成“$x$ 到其 $2^k$ 级祖先路径上边的字符拼接得到的串”，这可以由倍增算法的一种树上改造 $O(|T|\log |T|)$ 求出，其中 $|T|$ 为树的结点数。</p>
</li>
</ul>
<p>论文中还提到了一种基于基本字串字典的求 $w$ 所有本原 $k$ 次方串的方法（$k\ge 3$），但这方面的应用似乎可以被 Runs 理论全面取代，因此这里不做介绍。</p>
<ul>
<li><p><strong>例题：[Luogu P8006] String Rearrangement in Phantom</strong></p>
</li>
<li><p>题目大意：给定字符串 $w$，$q$ 次询问，每次给定 $l_1,r_1,l_2,r_2$，求有多少个字符串三元组 $(A,B,C)$，使得 $w[l_1,r_1]=A+B+C, w[l_2,r_2]=C+\operatorname{Rev}(B)+A$。</p>
<p>$|w|\leq 2\times 10^5, q\leq 10^5$</p>
</li>
<li><p>题解：$A,C$ 分别可以表示成 $O(\log |w|)$ 个等差数列，枚举一对等差数列，然后考虑 $A,C$ 分别在这两个等差数列中的方案数。</p>
<p>设这两个等差数列分别对应的可能的 $A,C$ 为 $A_1,\ldots,A_k$，$C_1,\ldots,C_l$，长度递减排列。那么 $A_1,\ldots,A_k$ 中相邻两项的差应该是个定值（$A_1$ 的长度等于最小周期的后缀），记为 $u$，同理 $C_1,\ldots,C_l$，这个差值记为 $v$。</p>
<p>如果 $|A_1|+|C_1|\leq len$（$len$ 是给定子串的长度），那么它们的出现无交，我们只需要检查两个子串各删掉对应 $A_1,C_1$ 的部分后是否互反，以及 $u,v$ 是否互反（即 $A_1$ 的长度为 $|u|$ 的前缀和后缀是否互反，$v$ 同理）即可确定答案。</p>
<p>但是如果 $|A_1|+|C_1|&gt;len$，那么上面的做法就会失效。此时，如果 $|A_3|+|C_1|\leq len$ 或者 $|A_1|+|C_3|\leq len$，那么我们可以特判 $A_1,A_2$ 或 $C_1,C_2$ 然后应用上面的方法。否则，根据引理 2（有一些细微的不同，但整体是类似的），可以知道 $A_1,\ldots,A_k$ 和 $C_1,\ldots,C_l$ 公差相同，设为 $d$。</p>
<p>此时，中间一整段（从 $A_k$ 结尾到 $C_l$ 开头，所有与 $B$ 的选取有关的位置）都有周期 $d$，我们任取一组总长最长的不相交的 $A_i,C_j$，如果中间的部分互反，则所有 $A_{i+k},C_{j-k}$ 也是可行的，因为中间的部分都一样。此时如果 $A_i,C_{j+1}$ 也满足中间的部分互反，说明加入一个周期不会对 $B$ 的合法性产生影响，因此这时任何一对不相交的 $A,C$ 都是合法的。</p>
<p>时间复杂度 $O(|w|\log |w|+q\log^2|w|)$。</p>
</li>
</ul>
<hr>
<h2 id="4-对称压缩-SAM-基本子串结构"><a href="#4-对称压缩-SAM-基本子串结构" class="headerlink" title="4. 对称压缩 SAM / 基本子串结构"></a>4. 对称压缩 SAM / 基本子串结构</h2><blockquote>
<p>论文：徐翊轩，浅谈压缩后缀自动机，IOI 2020 集训队论文集</p>
<p>论文：许庭强，一类基础子串数据结构，IOI 2023 集训队论文集</p>
</blockquote>
<p><strong>基本子串结构</strong>和<strong>基本子串字典</strong>基本上是完全没有关系的两个东西。</p>
<p>在前置知识中我们介绍了后缀自动机。后缀自动机是接收 $w$ 所有子串的最小 DFA，那么不知大家在初学 SAM 时是否有过这样的疑问：为什么它叫<strong>后缀自动机</strong>而不是<strong>子串自动机</strong>之类的？这里我们尝试从这个问题出发，引入本节想要介绍的对称压缩 SAM 和基本子串结构。</p>
<p>后缀自动机的特点是每个结点代表的是一系列字符串，且它们都是其中最长者的后缀，这或许可以作为名称的由来（尽管本身可能不是这么来的）。我们换一个视角来看，SAM 是一个“向左扩展”的自动机，因为任意给定一个子串 $w[l,r]$，$w[l,r]$ 对应的 SAM 结点上的最长字符串一定是某个 $w[l’,r]$，使得 $w[l’,r]$ 与 $w[l,r]$ 的 $\operatorname{Endpos}$ 相同，且 $l’$ 最小。那么 $w[l’,r]$ 可以看成是在 $w[l,r]$ 左边反复加字符，直到再加字符会改变其出现位置（我们可以用 $\operatorname{Endpos}$ 来描述出现位置，也可以直接用出现次数来描述）。</p>
<p>于是我们想：有没有向右扩展的自动机呢？当然这就是反串的 SAM。那么有没有向两侧扩展的自动机呢？</p>
<ul>
<li><strong>定义：考虑串 $w$。对于任意一个 $w$ 的子串 $u$，定义 $\operatorname{occ}(u)$ 为 $u$ 在 $w$ 中的出现次数。$\operatorname{Lext}(u)$ 为最长的以 $u$ 为后缀的串 $u’$，使得 $u’$ 和 $u$ 在 $w$ 中的 $\operatorname{occ}$ 相同；$\operatorname{Rext}(u),\operatorname{Ext}(u)$ 类似，只不过定义中 $u$ 分别是 $u’$ 的前缀和子串。</strong></li>
</ul>
<p>首先要说明 $\operatorname{Lext},\operatorname{Rext},\operatorname{Ext}$ 是良定义的。前面已经说过了 $\operatorname{Lext}(u)$ 其实就是 $u$ 对应 SAM 结点对应的最长子串；那么同理 $\operatorname{Rext}(u)$ 相应地就是 $u$ 对应反串 SAM 结点对应的最长子串，而 $\operatorname{Ext}$ 可以看成由 $\operatorname{Lext}(u)$ 和 $\operatorname{Rext}(u)$ 拼接而成。可以直观理解为：$\operatorname{Ext}(u)$ 是每次 $u$ 出现时前后一定会连带着一起出现的那部分东西。</p>
<p>那么现在我们想建立一种结构，使得 $u$ 可以直接链接到 $\operatorname{Ext}(u)$，或者说把一族 $\operatorname{Ext}$ 相同的子串放到一起（例如 SAM 就是把一族 $\operatorname{Lext}$ 相同的子串放到一起）。</p>
<p>我们从 SAM 出发构建这一结构，SAM 已经完成了向左扩展，只需再实现向右扩展即可。对于 SAM 上的一个结点 $x$，如果其出度大于 $1$，那么它一定是不可向右扩展的，因为它右侧的内容不唯一；如果它代表的是某个后缀，那么它一定也是不可向右扩展的，因为后缀的右边没东西了。但是如果 $x$ 不代表后缀，且出度等于 $1$，那么就说明它每次出现后面接的字符是相同的（就是唯一的出度上的那个字符），这代表 $x$ 可以和它的出边指向的点 $y$ 合并，它们对应的 $\operatorname{Ext}$ 相同。重复这样的合并，就有：</p>
<ul>
<li><strong>定义：将 $w$ 的 SAM 上出度为 $1$ 且不代表后缀的结点与其出边指向的结点合并，得到的自动机称为 $w$ 的压缩后缀自动机。</strong></li>
</ul>
<p>注意，上面的论文中将这个东西称为“完整压缩后缀自动机”，相应地本文中的后缀树在论文中被称为“完整后缀树”，而论文中相应的“压缩后缀自动机”和“后缀树”对应的是本文中的隐式压缩后缀自动机（即把所有出度为 $1$ 的点都合并掉，不管是不是后缀）和隐式后缀树。</p>
<p>下图展示了 $\texttt{abbab}$ 和它的反串 $\texttt{babba}$ 的 SAM 和压缩 SAM，灰色结点为后缀对应的结点：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8t9xzsya.png" alt=""></p>
<p>压缩 SAM 虽然是一个两侧扩展的自动机，但是它的转移边仍然是单向的——沿着转移边只能从前往后加字符。不过注意到反串 SAM 也可以压缩，并且得到的压缩 SAM 和正串压缩 SAM 应该是结点一一对应的（因为每个结点都是一个 $\operatorname{Ext}$ 等价类，而 $\operatorname{Ext}$ 和正反无关）。所以可以提出以下更有对称性的结构：</p>
<ul>
<li><strong>定义：将 $w$ 的正反 SAM 分别压缩，对应结点叠合，同时保留两个自动机上的转移，得到的结构称为 $w$ 的对称压缩后缀自动机。</strong></li>
</ul>
<p>对称压缩 SAM 上有两种不同类的转移，一种是向后加字符，另一种是向前加字符。因此，对称压缩 SAM 相比普通 SAM 在处理字符串问题上的优势就体现为：<strong>能够解决同时需要往左右两边加字符的问题</strong>。</p>
<p>对称压缩 SAM 刻画了不同的 $\operatorname{Ext}$ 等价类之间的转移关系，但是很多问题要求我们针对一个等价类内部的性质进行研究。$\operatorname{Ext}$ 等价的结构比 $\operatorname{Endpos}$ 等价这样的结构要复杂一些，下面介绍一种用来解释 $\operatorname{Ext}$ 等价类内部性质及它们之间的关系的一种字符串整体结构——基本子串结构。</p>
<p>我们将 $w$ 的所有子串画在一个 $|w|\times |w|$ 网格图中，横坐标表示子串的左端点，纵坐标表示右端点，然后将处于压缩 SAM 上同一结点的子串染为同种颜色，得到的结构就称之为（初步的）<strong>基本子串结构</strong>，每个同色连通块称为一个<strong>块</strong>。</p>
<p>下图展示了 $\texttt{abbab}$ 的正反压缩 SAM、对称压缩 SAM 和基本子串结构：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/aabashdj.png" alt=""></p>
<p>以同种颜色边框围成的区域就是一个块，本质不同的块与压缩 SAM 上的结点一一对应。而压缩 SAM 上的边即可看成横向或纵向（分别对应反串压缩 SAM 和正串压缩 SAM）相邻的两块之间的转移，这种转移关系在上图也画出来了。</p>
<p>根据对压缩 SAM 的讨论，我们可以得到如下结论：</p>
<ul>
<li><p><strong>结论 1：每个块是一个上端和左端对齐的阶梯形网格图，即存在 $l_a,l_b,r$ 使得这一块中的所有格子恰为 $\{(x,y)\mid l_a\leq x\leq l_b, f(l_a)\leq y\leq r\}$，其中 $f$ 单调不降。</strong></p>
</li>
<li><p>证明：首先我们说明一个块是上端和左端对齐的，即上边界和左边界不会是凹的，即如果存在两个子串 $w[l_1,r_1]$ 和 $w[l_2,r_2]$ 属于同一块，则 $w[\min(l_1,l_2),\max(r_1,r_2)]$ 也属于这一块。这很容易说明，只要考虑 $\operatorname{Ext}$ 即可，这些串的 $\operatorname{Ext}$ 都是相同的。</p>
<p>再说明它确实是阶梯型网格图。现在我们已经知道块有一个左上顶点，即所有块中串的 $\operatorname{Ext}$，记这个极长的串为 $w[l,r]$。我们只需说明如果 $\operatorname{Ext}(w[l’,r’])=w[l,r] ([l’,r’]\subset [l,r])$ 则 $\operatorname{Ext}(w[l’-1,r’])=w[l,r] (l’&gt;l)$ 和 $\operatorname{Ext}(w[l’,r’+1])=w[l,r] (r’&lt;r)$ 即可，这由 $\operatorname{Ext}$ 的定义可以直接得到。</p>
</li>
</ul>
<p>于是，对于一个块 $C$，可以定义其左上角的格子对应的串为其代表元 $\operatorname{Rep}(C)$。</p>
<ul>
<li><p><strong>结论 2：每个串出现且只出现在一种块中，且在块中只出现了一次，每种本质不同的块 $C$ 恰好出现了 $\operatorname{occ}(\operatorname{Rep}(C))$ 次。</strong></p>
</li>
<li><p>证明：每个串显然只能出现在一种块中，因为其 $\operatorname{Ext}$ 是唯一的。$\operatorname{Rep}(C)$ 在 $C$ 中只出现了一次，而它在整个串中出现了 $\operatorname{occ}(\operatorname{Rep}(C))$ 次，所以 $C$ 就出现了 $\operatorname{occ}(\operatorname{Rep}(C))$ 次，而 $C$ 中的其他串也出现了 $\operatorname{occ}(\operatorname{Rep}(C))$ 次，所以它们不可能在 $C$ 中出现两次或以上（否则总次数就不对了）。</p>
</li>
</ul>
<p>对于一个块 $C$，定义 $h(C)$ 为其左边界的高度，$w(C)$ 为其上边界的宽度。</p>
<ul>
<li><p><strong>结论 3：一块中的一行对应一个 $\operatorname{Endpos}$ 等价类，从而对应一个 SAM 结点；一列对应一个 $\operatorname{Startpos}$ 等价类，从而对应一个反串 SAM 结点。</strong></p>
</li>
<li><p>证明：以结论前半部分为例。根据 SAM 部分中讲过的内容，一个 $\operatorname{Endpos}$ 等价类一定是网格图上某一行的一个连续段。一块中的一行 $\operatorname{Endpos}$ 一定相同，且如果往两边扩展则 $\operatorname{occ}$ 都不同，$\operatorname{Endpos}$ 肯定不会相同，所以又不能扩展，从而就是一个 $\operatorname{Endpos}$ 等价类。</p>
</li>
<li><p><strong>结论 4：$\sum_C h(C)+w(C)=O(|w|)$，其中求和是对本质不同的块求和。</strong></p>
</li>
<li><p>证明：由结论 3，每个 SAM 结点会为 $\sum_C h(C)$ 贡献 $1$，每个反串 SAM 结点会为 $\sum_C w(C)$ 贡献 $1$，由 SAM 结点数的结论知 $\sum_C h(C)+w(C)=O(|w|)$。</p>
</li>
</ul>
<p>有了结论 3，我们还可以进一步研究 SAM 上的后缀链接对应到基本子串结构上的结果。根据上面的对应，SAM 上的后缀链接就发生在横向相邻的两块的交界处，反串 SAM 上的后缀链接就发生在纵向相邻的两块的交界处。</p>
<p>结论 4 是很多算法复杂度的保证。例如，如果在每一块上有一个 $O((h(C)+w(C))\operatorname{polylog}(h(C)+w(C)))$ 的算法，则对每一块做一遍的话，这个算法的复杂度就是 $O(|w|\operatorname{polylog} |w|)$。</p>
<p>之前我们介绍了用基本子串字典处理区间 Border 的方法，而基本子串结构给了另一种看待区间 Border 问题的视角。</p>
<p>子串 $w[l,r]$ 的 Border 即同时为它的前缀和后缀的串的集合，而这相当于是 $w[l,r]$ 在正串 SAM 上的链接树祖先链与反串 SAM 上的链接树祖先链的交。现在让我们考虑对两棵链接树都进行<strong>重链剖分</strong>，然后我们按照这种重链剖分来确定一种特定的每个块在网格图上的位置。我们知道每个块在网格中出现了多次，我们希望给每个块选择其中一个它出现的位置，使得<strong>所有重链上的后缀链接都是直接的</strong>，即都是同一行/列的两块之间的转移。</p>
<p>这（给块选位置）对于后续的算法并不是必要的，但它能直观地告诉我们一些性质，所以下面我们递归地给出一种构造，以正串 SAM 的链接树为例：从叶子出发，叶子的出现次数当然都是 $1$，它们的位置确定。对于每个非叶结点，将它安放在它的重儿子放在的位置的右侧（不难发现一个块中所有 SAM 结点对应的重儿子可以认为都来自同一块，事实上同一块中所有 SAM 结点对应的子树是完全同构的）。</p>
<p>下图展示了 $\texttt{abbab}$ 的正反串 SAM 链接树的重链剖分和对应的基本子串结构中块的位置，可以看到，重边都是横平竖直的。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/uxtzry61.png" alt=""></p>
<p>对于正串 SAM 链接树上一条重链，令其编号为其叶结点所在的行；对于反串，则是叶结点所在列。</p>
<ul>
<li><p><strong>结论 5：同一个块中，所有正（反）串 SAM 结点对应的正（反）串 SAM 链接树上重链编号连续。</strong></p>
</li>
<li><p>证明：因为在一条重链上，所以每个结点与其重链上的叶子在同一行（列），根据编号的定义知道是连续的。</p>
</li>
</ul>
<p>下面我们回到区间 Border 问题，现在问题已经转化为寻找两棵树上两个祖先链的交，我们先把祖先链转化为 $O(\log |w|)$ 条重链段，虽然两条祖先链就会有 $O(\log^2 |w|)$ 个重链对，但是显然只有其中 $O(\log |w|)$ 对可能会相交（因为相交至少要长度相等，然后可以双指针一下），我们分别考虑每一对。</p>
<p>考虑每个正串 SAM 上的点，它对应的是基本子串结构某个块的一行，于是其中所有串就属于这一块中的不同的列，根据结论 5，这些列对应的反串 SAM 结点所在重链编号连续，所以每个正串 SAM 结点对应的是一个<strong>反串 SAM 重链编号的区间</strong>，而我们要查询的就是正串 SAM 某条重链上有多少个点对应的区间包含某个给定的反串重链。</p>
<p>但是注意我们考虑的并不是一整条重链，而只是重链的一个前缀（靠近根的部分），这可以通过加上一维长度来限制，即我们所求的是正串 SAM 一条重链和反串 SAM 一条重链的交集中长度 $\leq l$ 的那部分。于是我们把上面的对应关系扩展一下，每个正串 SAM 结点对应的是一个<strong>反串 SAM 重链编号、长度为坐标轴的二维平面中，一条斜率为 $1$ 的斜线段。</strong></p>
<p>以区间 Border 计数为例，对于每条正串 SAM 重链，它对应的数据结构问题可以描述为：给定二维平面中若干个斜率为 $1$ 的斜线段，若干次询问一条平行于 $y$ 轴的直线段与多少个斜线段有交，这可以简单地转化为一个二维数点。从而我们用基本子串结构也解决了区间 Border 问题，但复杂度相比基本子串字典多个 $\log$（因为每个询问要进行 $O(\log |w|)$ 次二维数点询问）。</p>
<ul>
<li><p><strong>例题：[SDOI / SXOI 2022] 子串统计</strong></p>
</li>
<li><p>题目大意：给定一个字符串 $w$，令 $T_0=w$，$T_i$ 是在 $T_{i-1}$ 的基础上删除第一个或最后一个字符得到的串，最后 $T_{n-1}$ 是一个只包含一个字符的串。总共有 $2^{n-1}$ 种删除方案（尽管得到的 $T$ 序列可能有一些是相同的），每种方案的权值定义为 $\prod_{i=0}^{n-1}\operatorname{occ}(T_i)$，求所有方案的权值和对 $998244353$ 取模。</p>
<p>$|w|\leq 10^5$</p>
</li>
<li><p>题解：每种方案可以看成是一条在基本子串结构上从左上角走到反对角线 $x=y$ 上任何一个点的只能往右或往下走的路径，我们要对所有路径上的点权乘积求和，由于权值用 $\operatorname{occ}$ 定义，所以同一块内所有点的权值相同。不妨把路径反过来，变成从对角线上的任何一个点走回到左上角。</p>
<p>我们单独考虑一块，如果路径经过这一块，那么一定是从这一块的右下轮廓上某个点出发，走到左上边界的某个点，而这部分的贡献是可以用一个经典的分治 NTT 算出，所以只要（按照从右下到左上的顺序）对每一块都算一遍贡献即可，相邻块之间的贡献可以在边界处（即正反 SAM 后缀链接）转移。</p>
<p>对某一块 $C$ 算的复杂度是 $O((h(C)+w(C))\log^2(h(C)+w(C)))$，所以总复杂度 $O(|w|\log^2 |w|)$。</p>
</li>
<li><p><strong>例题：[数据删除]</strong></p>
<p>稍后公布。</p>
</li>
</ul>
<hr>
<h2 id="5-Lyndon-分解-Significant-Suffix"><a href="#5-Lyndon-分解-Significant-Suffix" class="headerlink" title="5. Lyndon 分解 / Significant Suffix"></a>5. Lyndon 分解 / Significant Suffix</h2><blockquote>
<p>论文：万成章，浅谈与 Lyndon 理论有关的字符串组合问题，IOI 2022 集训队论文集</p>
</blockquote>
<p>Lyndon 理论是用来解决与字典序相关的问题的一套理论，不过在代数上它似乎有别的用处，但这和本文无关。</p>
<ul>
<li><strong>定义：如果一个串 $w$ 满足它小于它的所有非空真后缀，即 $\forall i\in [2,|w|], w&lt;w[i,|w|]$，则称 $w$ 是一个 </strong>Lyndon 串<strong>。</strong></li>
</ul>
<p>由于 $w$ 一定比它的后缀长，所以对于 Lyndon 串 $w$ 必然有 $w\lhd w[i,|w|]$。</p>
<p>再介绍一个和 Lyndon 串有关的概念。对于字符串 $w$，形如 $w[i,|w|]+w[1,i-1] (i\in [1,|w|])$ 的串称为 $w$ 的一个<strong>循环表示</strong>，如果 $w$ 是其所有循环表示中最小的，则称 $w$ 是一个 <strong>Necklace（项链）</strong>。</p>
<ul>
<li><strong>定义：如果一个串 $w$ 满足存在一个 Lyndon 串 $u$ 使得 $w=u^ku’$，其中 $u’$ 是 $u$ 的真前缀，则称 $w$ 是一个近似 Lyndon 串。</strong></li>
</ul>
<p>对于字符串 $w$，如果存在一系列 Lyndon 串 $w_1,\ldots,w_k$ 满足 $w_i\ge w_{i+1}$ 且 $w=w_1+w_2+\ldots +w_k$，则称 $w=w_1+w_2+\ldots w_k$ 是 $w$ 的 <strong>Lyndon 分解</strong>，每个 $w_i$ 为 $w$ 的一个 <strong>Lyndon 因子</strong>。</p>
<p>我们下面证明，一个串 $w$ 的 Lyndon 分解是存在且唯一的。</p>
<ul>
<li><p><strong>引理 1：若 $u,v$ 都是 Lyndon 串且 $u&lt;v$，则 $uv$ 是 Lyndon 串。</strong></p>
</li>
<li><p>证明：如果 $u\sqsubset v$ 则由 $v$ 是 Lyndon 串知 $uv&lt;v$；如果 $u\lhd v$ 则显然 $uv&lt;v$。故无论如何 $uv&lt;v$。</p>
<p>对于 $v$ 的非空后缀 $v’$，有 $uv&lt;v\leq v’$，对于 $u$ 的非空真后缀 $u’$，有 $u\lhd u’\to uv\lhd u’v$，因此 $uv$ 小于它的所有非空真后缀，即 $uv$ 是 Lyndon 串。</p>
</li>
<li><p><strong>引理 2：若 $w=w_1+\ldots +w_k$ 是 $w$ 的 Lyndon 分解，则 $w$ 的最小非空真后缀为 $w_k$。</strong></p>
</li>
<li><p>证明：设 $w$ 的最小非空真后缀为 $u=u’w_i\ldots w_k$，其中 $u’$ 是 $w_{i-1}$ 的非空后缀，则 $u\ge u’\ge w_{i-1}\ge w_k$，而 $w_k$ 是一个后缀，所以 $u$ 只能等于 $w_k$。</p>
</li>
</ul>
<p>根据引理 1 可以说明 Lyndon 分解的存在性：初始时令每个字符都是一个 Lyndon 因子，然后不断合并相邻的满足 $w_i&lt;w_{i+1}$ 的 Lyndon 因子 $w_i,w_{i+1}$，最后就得到了一个 Lyndon 分解（在下一节中，我们将给出一个以此为基础的 Lyndon 分解算法）。</p>
<p>根据引理 2 可以说明 Lyndon 分解的唯一性：最后一个 Lyndon 因子总是最小非空真后缀，删掉它后递归即可。至此我们成功证明了 Lyndon 分解是唯一存在的。</p>
<p>我们可以将 Lyndon 分解中相邻相同的 Lyndon 因子写在一起，成为 $w=w_1^{p_1}\ldots w_k^{p_k}$ 的形式，其中 $w_1&gt;w_2&gt;\ldots &gt;w_k$。</p>
<ul>
<li><p>Duval 算法：$O(|w|)$ 地求出 $w$ 的 Lyndon 分解。</p>
<p>从前往后依次加入 $w$ 的每个字符，一边加一边分解。设当前加入到字符 $w[i]$，我们维护当前前缀一个还没有被分解的后缀 $w[j,i]$，我们时刻保证这个后缀是一个近似 Lyndon 串，对应的 Lyndon 串长度为 $k$，即设 $u=w[j,j+k-1]$，$u$ 是一个 Lyndon 串且 $w[j,i]=u^tu’$，$u’$ 是 $u$ 的真前缀。现在我们加入字符 $w[i+1]$：</p>
<ul>
<li><p>若 $w[i+1]=w[i+1-k]$，则自然延续近似 Lyndon 串即可；</p>
</li>
<li><p>若 $w[i+1]&gt;w[i+1-k]$，则此时 $w[j,i+1]$ 本身是一个 Lyndon 串了，所以我们令 $k\leftarrow i-j+2$。</p>
</li>
<li><p>若 $w[i+1]&lt;w[i+1-k]$，则 $w[j,i+1]$ 不再是一个近似 Lyndon 串，我们将 $w[j,j+k-1],w[j+k,j+2k-1],\ldots$ 这些 Lyndon 串分解出来（它们是相等的），作为 $w$ 的 Lyndon 因子，直到 $j+pk-1\ge i+1$。令新的 $j$ 为 $j+(p-1)k$，然后将 $i$ 回滚至 $j$，$k\leftarrow 1$，重新加入一遍 $w[j],\ldots,w[i]$ 这些字符，加入过程同上。</p>
</li>
</ul>
<p>若所有字符都加入完毕了，则类似上面最后一种情况，把当前近似 Lyndon 串 $w[j,|w|]$ 的 Lyndon 前缀 $w[j,j+k-1],w[j+k,j+2k-1],\ldots$ 分解出来，然后将 $i$ 回滚到最后余下一段的开头再加一遍。</p>
</li>
</ul>
<p>Duval 算法的正确性可以直接验证——它分解出的每个子串确实都是 Lyndon 串，且字典序确实递减。</p>
<p>Duval 算法的复杂度不难证明。每当分解出一段 Lyndon 因子 $w_i^{p_i}$ 时，$i$ 会回滚 $w$ 的一个前缀，从而回滚的总长度不超过 $\sum |w_i|$，从而不超过 $|w|$，因此 $i$ 前进的次数也是 $O(|w|)$，每次前进可以 $O(1)$ 完成判断，而分解的总复杂度是 $O(|w|)$，所以整个算法的复杂度为 $O(|w|)$。</p>
<ul>
<li><strong>定义：如果 $w$ 的一个后缀 $w’$ 满足：存在一个 $v$ 使得对于 $w$ 的任何后缀 $w’’$ 都有 $w’v\leq w’’v$，则称 $w’$ 是 $w$ 的一个 Significant Suffix。$w$ 的所有 Significant Suffix 的集合记为 $\operatorname{SS}(w)$。</strong></li>
</ul>
<p>Significant Suffix 有一个性质：如果 $w’\in \operatorname{SS}(w)$，那么不存在另一个后缀 $w’’$ 使得 $w’’\lhd w’$ 的那些后缀 $w’$，这是比较好理解的：$w’’\lhd w’$ 可以推出 $w’’v\lhd w’v$。</p>
<p>一些与字典序相关的问题可以归于对 Significant Suffix 的讨论，所以我们首先介绍其一些性质。</p>
<ul>
<li><p><strong>引理 3：如果 $v,uv,u^2v (u\neq \varepsilon)$ 都是 $w$ 的后缀，则 $uv\notin \operatorname{SS}(w)$。</strong></p>
</li>
<li><p>证明：事实上我们有 $uvy&lt;vy\iff u^2vy&lt;uvy$，所以 $uvy$ 总不是最小的。</p>
</li>
</ul>
<p>设 $w$ 的分解为 $w=w_1^{p_1}w_2^{p_2}\ldots w_k^{p_k}$，以下引理揭示了 Lyndon 分解与 Significant Suffix 的联系：</p>
<ul>
<li><p><strong>引理 4：$w$ 的 Significant Suffix 一定形如 $w_i^{p_i}\ldots w_k^{p_k}$，将这个串记为 $s_i$。</strong></p>
</li>
<li><p>证明：第一步说明 Significant Suffix 形如 $w_i^t\ldots w_k^{p_k}$。考虑形如 $uw_i^t\ldots w_k^{p_k}$ 的后缀，其中 $u$ 是 $w_i$ 的真后缀，则 $w_i\lhd u$，故 $w_i^{t+1}\ldots w_k^{p_k}\lhd uw_i^t\ldots w_k^{p_k}$，这说明了以 $u$ 开头的这个后缀不是 Significant Suffix。</p>
<p>第二步说明上述形式中一定有 $t=p_i$，若 $0&lt;t\ne p_i$，则考虑 $w_i^{t-1}\ldots w_k^{p_k}, w_i^t\ldots w_k^{p_k}, w_i^{t+1}\ldots w_k^{p_k}$ 这三个后缀，形成了引理 3 中 $v,uv,u^2v$ 的形式，于是其中的 $w_i^t\ldots w_k^{p_k}$ 就不是 Significant Suffix。</p>
</li>
</ul>
<p>设 $\operatorname{SS}(w)$ 从短到长排序为 $u_1,\ldots,u_t$，那么对于任意 $i,j$ 都不能有 $u_i\lhd u_j$ 或 $u_j\lhd u_i$，从而只能 $u_1\sqsubset u_2\sqsubset \ldots \sqsubset u_t$。</p>
<p>现在考虑 $s_1,\ldots,s_k$（在引理 4 中定义）中哪些可能成为 Significant Suffix，根据上面的讨论，一个必要条件显然是 $s_{i+1}\sqsubset s_i$。</p>
<ul>
<li><p><strong>引理 5：$s_{i+1}\sqsubset s_i\iff s_{i+1}\sqsubset w_i\iff i\ge \lambda$，其中 $s_\lambda$ 为 Duval 算法第一次比较完 $w$ 的末尾时的近似 Lyndon 串。</strong></p>
</li>
<li><p>证明：如果 $i&lt;\lambda$，说明 Duval 算法过程中某一时刻近似 Lyndon 串为 $w_i^{p_i}w’$ 且下一个字符为 $c$，其中 $w’$ 是 $w_i$ 的真前缀，$c&gt;w_i[|w’|+1]$，这说明 $w_i\lhd s_{i+1}$，从而 $s_{i+1}\not\sqsubset s_i, s_{i+1}\not\sqsubset w_i$。</p>
<p>如果 $i=\lambda$，则 $s_i$ 是近似 Lyndon 串，同时根据 Duval 算法的规则可知 $s_{i+1}\sqsubset w_i$，于是 $s_{i+1}\sqsubset s_i$，同时 Lyndon 串的前缀一定是近似 Lyndon 串，所以 $s_{i+1}$ 也是近似 Lyndon 串，于是对于 $i&gt;\lambda$ 的情况可以归纳。</p>
</li>
</ul>
<p>于是我们说明了 Significant Suffix 只会在 $s_\lambda,\ldots,s_k$ 中诞生（事实上，它们全都是 Significant Suffix，但这通常不很关键），我们由此分析一下 $|\operatorname{SS}(w)|$：由引理 5 知 $s_{i+1}\sqsubset w_i$，从而，$|s_i|&gt;2|s_{i+1}|$，所以 $|s_\lambda|&gt;2^{k-\lambda}|s_k|$，而 $|s_\lambda|\leq |w|$，所以 $k-\lambda&lt; \log_2(|w|)$，于是：</p>
<ul>
<li><strong>结论 1：$|\operatorname{SS}(w)|=O(\log |w|)$，且较长的 Significant Suffix 长度大于较短的 Significant Suffix 的长度的两倍。</strong></li>
</ul>
<p>现在让我们回答一个基本的问题：给定 $v$，求最小的 $w’v$，其中 $w’$ 是 $w$ 的后缀，将答案记为 $\operatorname{Minsuf}(w,v)$。为此，我们首先引入一个比较规则：</p>
<ul>
<li><p><strong>引理 6：$uv&lt;v\iff u^{\infty}&lt;v$</strong></p>
</li>
<li><p>证明：设 $v=u^tu’s$，其中 $u’$ 是 $u$ 的真前缀，$s=\varepsilon$ 或 $s[1]\ne u[|u’|+1]$。若 $s=\varepsilon$，则 $v\sqsubset uv$ 且 $v\sqsubset u^{\infty}$；若 $s[1]&gt;u[|u’|+1]$，则 $uv\lhd v$ 且 $u^{\infty}\lhd v$；若 $s[1]&lt;u[|u’|+1]$，则 $v\lhd uv$ 且 $v\lhd u^{\infty}$。无论如何，结论都成立。</p>
</li>
</ul>
<p>对于 $i\ge \lambda$，我们知道 $s_{i+1}\sqsubset w_i$。因此设 $w_i=s_{i+1}y_i$（令 $s_{k+1}=\varepsilon$），再设 $x_i=y_is_{i+1}$，那么有 $s_i=s_{i+1}x_i^{p_i}$。现在我们想知道哪个 $s_iv$ 是最小的，那么可以比较一下 $s_iv$ 和 $s_{i+1}v$，去掉公共前缀 $s_{i+1}$ 后就是要比较 $x_i^{p_i}v$ 和 $v$。由引理 6，我们知道 $x_i^{p_i}v&lt;v\iff x_i^{\infty}&lt;v$。</p>
<ul>
<li><p><strong>引理 7：$x_i^{\infty}&gt;x_{i+1}^{\infty}$。</strong></p>
</li>
<li><p>证明：显然 $x_i^{\infty}&gt;y_i$，只需证明 $y_i&gt;x_{i+1}^{\infty}$ 即可。在两边前面都加上一个 $s_{i+1}$，等价于要证 $s_{i+1}y_i&gt;s_{i+1}x_{i+1}^{\infty}$，而 $s_{i+1}y_i=w_i, s_{i+1}x_{i+1}^{\infty}=w_{i+1}^{\infty}$，由 $w_i$ 是 Lyndon 串以及 $w_{i+1}\sqsubset w_i$ 知 $w_i&gt;w_{i+1}w_i$（考虑删去一个公共前缀 $w_{i+1}$），于是由引理 6 知 $w_i&gt;w_{i+1}^{\infty}$，至此命题得证。</p>
</li>
</ul>
<p>因此只要我们找到一个 $x_{i-1}^{\infty}&gt;v&gt;x_i^{\infty}$，那么对于所有 $\lambda\leq j\leq i-1$ 都有 $x_j^{\infty}&gt;v$，对于所有 $i\leq j\leq k$ 都有 $x_j^{\infty}&lt;v$，于是我们就有：</p>
<ul>
<li><strong>结论 $2$：$\operatorname{SS}(w)=\{s_\lambda,\ldots,s_k\}$，且：$\operatorname{Minsuf}(w,v)=\begin{cases}s_\lambda v &amp; v&gt;x_\lambda^{\infty} \ s_iv &amp; x_{i-1}^{\infty}&gt;v&gt;x_i^{\infty} \ v &amp; x_k^{\infty}&gt;v\end{cases}$。</strong></li>
</ul>
<p>许多字典序相关问题都可以转化为求 $\operatorname{Minsuf}(w,v)$，例如最小后缀就是 $v=\varepsilon$；最大后缀就是字典序取反后 $v=\texttt{z}$（$\texttt{z}$ 是一个极大字符）；最小循环表示就是 $v=w$。</p>
<ul>
<li><p><strong>例题：[ZJOI 2017] 字符串</strong></p>
</li>
<li><p>题目大意：维护一个长度为 $n$ 的字符串（数字序列）$w$，支持 $q$ 次操作：区间加，求区间最小后缀。</p>
<p>$n\leq 2\times 10^5, q\leq 30000$</p>
</li>
<li><p>题解：既然有区间加这样的操作，自然尝试用线段树维护 $w$。不过现在关键的问题是我们无法直接从左右两边的最小后缀合并得到它们拼接后的最小后缀，不过如果我们维护了两边的所有 Significant Suffix，就可以进行合并了。</p>
<p>如果我们已知 $\operatorname{SS}(u)$ 和 $\operatorname{SS}(v)$，并且 $|v|\ge |u|$，那么根据上面的结论 1，$\operatorname{SS}(u)$ 中只有至多一个能够被选进 $\operatorname{SS}(uv)$，唯一的候选者自然就是 $\operatorname{Minsuf}(u,v)$。由于多算一些串进 $\operatorname{SS}(uv)$ 其实并没有关系（只要数量仍然是 $O(\log |uv|)$ 就行），所以我们就将 $\operatorname{SS}(v)\cup \{\operatorname{Minsuf}(u,v)\}$ 看作 $\operatorname{SS}(uv)$。从而我们可以在线段树上维护每个点对应子串的 Significant Suffix 集合（尽管可能多算一些串），如果查询两个子串大小关系的复杂度为 $O(\log n)$ 的话，一次 pushup 的复杂度就是 $O(\log^2 n)$。</p>
<p>查询时，只需要找到所有拆分出的线段树上的结点的所有 Significant Suffix 并选一个最小的即可，复杂度为 $O(\log^3 n)$。</p>
<p>考虑如何实现 $O(\log n)$ 比较两个子串大小关系。可以以修改的时间代价换查询的时间代价，采用分块，维护每个点到块末尾的哈希值和块端点到末尾的哈希值，即可 $O(\sqrt n)$ 修改，$O(1)$ 求出子串哈希值，从而套一个二分就能 $O(\log n)$ 查询子串 LCP 和比较子串大小。</p>
<p>复杂度为 $O(n\log^2 n+q(\log^3 n+\sqrt n))$，如果用线段树替代分块则为 $O(n\log^2 n+q\log^4 n)$。</p>
</li>
<li><p><strong>例题：[数据删除]</strong></p>
<p>稍后公布。</p>
</li>
<li><p><strong>例题：[数据删除]</strong></p>
<p>稍后公布。</p>
</li>
</ul>
<hr>
<h2 id="6-幂串-Runs"><a href="#6-幂串-Runs" class="headerlink" title="6. 幂串 / Runs"></a>6. 幂串 / Runs</h2><hr>
<h2 id="7-杂技"><a href="#7-杂技" class="headerlink" title="7. 杂技"></a>7. 杂技</h2><ul>
<li><p>广义 SAM</p>
</li>
<li><p>SAM 上的 DAG 剖分</p>
</li>
<li><p>回文串</p>
</li>
<li><p>Lyndon 计数问题</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/06/02/%E9%9A%8F%E7%AC%94%E9%80%89%E8%BE%91/%E9%9B%A8/" rel="prev" title="随笔选辑 - 雨">
                  <i class="fa fa-chevron-left"></i> 随笔选辑 - 雨
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/06/02/%E9%9A%8F%E7%AC%94%E9%80%89%E8%BE%91/%E6%88%91%E5%AF%B9OI%E7%9A%84%E6%83%B3%E8%B1%A1/" rel="next" title="随笔选辑 - 我对 OI 的想象">
                  随笔选辑 - 我对 OI 的想象 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ix35</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.0/katex.min.css" integrity="sha256-uik/hNqHWZldXh/0K35nqOSCff9F61/ZOFReqNOBgB0=" crossorigin="anonymous">



</body>
</html>
